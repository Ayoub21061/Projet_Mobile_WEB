generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  emailVerified Boolean @default(false)
  password  String?
  pseudo    String?
  photoUrl  String?
  age       Int?
  city      String?
  bio       String?
  image     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions        Session[]
  accounts        Account[]

  sports          UserSport[]
  equipment       UserEquipment[]
  availability    Availability[]
  createdMatches  Match[]
  participations  MatchParticipant[]
  ratingsGiven    Rating[] @relation("RatingsGiven")
  ratingsReceived Rating[] @relation("RatingsReceived")
  badges          UserBadge[]
  messages        Message[]

  @@map("user")
}


// model Session {
//   id        String   @id
//   expiresAt DateTime
//   token     String
//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
//   ipAddress String?
//   userAgent String?
//   userId    String
//   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@unique([token])
//   @@index([userId])
//   @@map("session")
// }

// model Account {
//   id                    String    @id
//   accountId             String
//   providerId            String
//   userId                String
//   user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
//   accessToken           String?
//   refreshToken          String?
//   idToken               String?
//   accessTokenExpiresAt  DateTime?
//   refreshTokenExpiresAt DateTime?
//   scope                 String?
//   password              String?
//   createdAt             DateTime  @default(now())
//   updatedAt             DateTime  @updatedAt

//   @@index([userId])
//   @@map("account")
// }

model Sport {
  id    Int    @id @default(autoincrement())
  name  String @unique
  icon  String?

  users   UserSport[]
  matches Match[]
  locations Location[]
}

model UserSport {
  id      Int   @id @default(autoincrement())
  userId  String
  sportId Int
  level   String
  position String?

  user  User @relation(fields: [userId], references: [id], onDelete: Cascade)
  sport Sport @relation(fields: [sportId], references: [id])

  @@unique([userId, sportId])
}


model Equipment {
  id   Int    @id @default(autoincrement())
  name String @unique

  users UserEquipment[]
}

model UserEquipment {
  userId      String
  equipmentId Int

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  equipment Equipment @relation(fields: [equipmentId], references: [id])

  @@id([userId, equipmentId])
}


model Availability {
  id        String    @id @default(uuid())
  userId    String
  dayOfWeek String
  startTime String
  endTime   String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Match {
  id           Int         @id @default(autoincrement())
  creatorId    String
  sportId      Int
  locationId   Int
  scheduleId   Int?        @unique
  matchDate    DateTime
  startTime    String
  endTime      String
  maxPlayers   Int
  levelRequired Level
  gender       Gender
  price        Int
  isPublic     Boolean     @default(true)
  privateCode  String?
  autoValidate Boolean     @default(true)
  deadline     DateTime?
  description  String?
  status       MatchStatus @default(OPEN)
  createdAt    DateTime    @default(now())

  creator     User       @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  sport       Sport      @relation(fields: [sportId], references: [id])
  location    Location   @relation(fields: [locationId], references: [id])
  schedule    Schedule?  @relation(fields: [scheduleId], references: [id])
  participants MatchParticipant[]
  messages    Message[]
  ratings     Rating[]
}

model Location {
  id        Int     @id @default(autoincrement())
  sportId   Int
  name      String
  address   String

  sport     Sport   @relation(fields: [sportId], references: [id])
  matches Match[]
  fields Field[]
}
model Field {
  id          Int        @id @default(autoincrement())
  locationId  Int
  name        String

  location    Location   @relation(fields: [locationId], references: [id])
  schedules   Schedule[]
}

model Schedule {
  id       Int     @id @default(autoincrement())
  fieldId  Int
  day      String  // "Monday", "Tuesday", ou "YYYY-MM-DD" si tu veux par date
  start    String  // format "HH:mm" (ex: "08:00")
  end      String  // format "HH:mm" (ex: "09:00")
  isAvailable Boolean @default(true) // Indique si le cr√©neau est disponible ou non

  field    Field   @relation(fields: [fieldId], references: [id])
  match    Match?
}

model MatchParticipant {
  id      Int    @id @default(autoincrement())
  matchId Int
  userId  String
  status  String @default("PENDING")
  joinedAt DateTime @default(now())
  team    String
  confirmed Boolean @default(false)

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
}

model Rating {
  id           Int      @id @default(autoincrement())
  matchId      Int
  raterId      String
  ratedUserId  String
  score        Int
  comment      String?
  createdAt    DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  rater User  @relation("RatingsGiven", fields: [raterId], references: [id], onDelete: Cascade)
  rated User  @relation("RatingsReceived", fields: [ratedUserId], references: [id], onDelete: Cascade)
}

model Badge {
  id          Int    @id @default(autoincrement())
  name        String @unique
  description String

  users UserBadge[]
} 

model UserBadge {
  userId  String
  badgeId Int
  earnedAt DateTime @default(now())

  user  User @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge Badge @relation(fields: [badgeId], references: [id])

  @@id([userId, badgeId])
}


model Message {
  id        Int      @id @default(autoincrement())
  matchId   Int
  senderId  String
  content   String
  isSystem  Boolean  @default(false)
  sentAt    DateTime @default(now())

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation(fields: [senderId], references: [id], onDelete: Cascade)
}

enum Level {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  PRO
}

enum Gender {
  MIXED
  MEN
  WOMEN
}

enum MatchStatus {
  OPEN
  ALMOST_FULL
  FULL
  CANCELLED
}

enum Day {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum ParticipantStatus {
  PENDING
  ACCEPTED
  REJECTED
}







